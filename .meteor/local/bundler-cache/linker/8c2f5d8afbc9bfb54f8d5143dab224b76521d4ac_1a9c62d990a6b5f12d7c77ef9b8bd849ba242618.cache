[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar Random = Package.random.Random;\nvar colors = Package['nooitaf:colors'].colors;\n\n/* Package-scope variables */\nvar InstanceStatus;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/konecty_multiple-instances-status/multiple-instances-status.js                                           //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nvar events = new (Npm.require('events').EventEmitter)(),\n\tcollectionName = process.env.MULTIPLE_INSTANCES_COLLECTION_NAME || 'instances',\n\tdefaultPingInterval = (process.env.MULTIPLE_INSTANCES_PING_INTERVAL || 10); // default to 10s\n\nvar Instances = new Meteor.Collection(collectionName);\n\nvar InstancesRaw = Instances.rawCollection();\n\n// if not set via env var ensures at least 3 ticks before expiring (multiple of 60s)\nvar indexExpire = parseInt(process.env.MULTIPLE_INSTANCES_EXPIRE || (Math.ceil(defaultPingInterval * 3 / 60) * 60));\n\nInstancesRaw.indexes()\n\t.catch(function() {\n\t\t// the collection should not exists yet, return empty then\n\t\treturn [];\n\t})\n\t.then(function(result) {\n\t\treturn result.some(function(index) {\n\t\t\tif (index.key && index.key['_updatedAt'] === 1) {\n\t\t\t\tif (index.expireAfterSeconds !== indexExpire) {\n\t\t\t\t\tInstancesRaw.dropIndex(index.name);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t})\n\t})\n\t.then(function(created) {\n\t\tif (!created) {\n\t\t\tInstancesRaw.createIndex({_updatedAt: 1}, {expireAfterSeconds: indexExpire});\n\t\t}\n\t});\n\nInstanceStatus = {\n\tname: undefined,\n\textraInformation: undefined,\n\n\tevents: events,\n\n\tgetCollection: function() {\n\t\treturn Instances;\n\t},\n\n\tregisterInstance: function(name, extraInformation) {\n\t\tInstanceStatus.name = name;\n\t\tInstanceStatus.extraInformation = extraInformation;\n\n\t\tif (InstanceStatus.id() === undefined || InstanceStatus.id() === null) {\n\t\t\treturn console.error('[multiple-instances-status] only can be called after Meteor.startup');\n\t\t}\n\n\t\tvar now = new Date(),\n\t\t\tinstance = {\n\t\t\t\t$set: {\n\t\t\t\t\tpid: process.pid,\n\t\t\t\t\tname: name\n\t\t\t\t},\n\t\t\t\t$currentDate: {\n\t\t\t\t\t_createdAt: true,\n\t\t\t\t\t_updatedAt: true\n\t\t\t\t}\n\t\t\t};\n\n\t\tif (extraInformation) {\n\t\t\tinstance.$set.extraInformation = extraInformation;\n\t\t}\n\n\t\ttry {\n\t\t\tInstances.upsert({_id: InstanceStatus.id()}, instance);\n\t\t\tvar result = Instances.findOne({_id: InstanceStatus.id()});\n\t\t\tInstanceStatus.start();\n\n\t\t\tevents.emit('registerInstance', result, instance);\n\n\t\t\tprocess.on('exit', InstanceStatus.onExit);\n\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\treturn e;\n\t\t}\n\t},\n\n\tunregisterInstance: function() {\n\t\ttry {\n\t\t\tvar result = Instances.remove({_id: InstanceStatus.id()});\n\t\t\tInstanceStatus.stop();\n\n\t\t\tevents.emit('unregisterInstance', InstanceStatus.id());\n\n\t\t\tprocess.removeListener('exit', InstanceStatus.onExit);\n\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\treturn e;\n\t\t}\n\t},\n\n\tstart: function(interval) {\n\t\tInstanceStatus.stop();\n\n\t\tinterval = interval || defaultPingInterval;\n\n\t\tInstanceStatus.interval = Meteor.setInterval(function() {\n\t\t\tInstanceStatus.ping();\n\t\t}, interval * 1000);\n\t},\n\n\tstop: function(interval) {\n\t\tif (InstanceStatus.interval) {\n\t\t\tInstanceStatus.interval.close();\n\t\t\tdelete InstanceStatus.interval;\n\t\t}\n\t},\n\n\tping: function() {\n\t\tvar count = Instances.update(\n\t\t\t{\n\t\t\t\t_id: InstanceStatus.id()\n\t\t\t},\n\t\t\t{\n\t\t\t\t$currentDate: {\n\t\t\t\t\t_updatedAt: true\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (count === 0) {\n\t\t\tInstanceStatus.registerInstance(InstanceStatus.name, InstanceStatus.extraInformation);\n\t\t}\n\t},\n\n\tonExit: function() {\n\t\tInstanceStatus.unregisterInstance();\n\t},\n\n\tactiveLogs: function() {\n\t\tInstances.find().observe({\n\t\t\tadded: function(record) {\n\t\t\t\tvar log = '[multiple-instances-status] Server connected: ' + record.name + ' - ' + record._id;\n\t\t\t\tif (record._id == InstanceStatus.id()) {\n\t\t\t\t\tlog += ' (me)';\n\t\t\t\t}\n\t\t\t\tconsole.log(log.green);\n\t\t\t},\n\t\t\tremoved: function(record) {\n\t\t\t\tvar log = '[multiple-instances-status] Server disconnected: ' + record.name + ' - ' + record._id;\n\t\t\t\tconsole.log(log.red);\n\t\t\t}\n\t\t});\n\t},\n\n\tid: function() {}\n};\n\nMeteor.startup(function() {\n\tvar ID = Random.id();\n\n\tInstanceStatus.id = function() {\n\t\treturn ID;\n\t};\n});\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nPackage._define(\"konecty:multiple-instances-status\", {\n  InstanceStatus: InstanceStatus\n});\n\n})();\n","servePath":"/packages/konecty_multiple-instances-status.js"}]