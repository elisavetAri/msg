{"head":"<link rel=\"stylesheet\" href=\"https://cdn.webrtc-experiment.com/style.css\">\r\n\r\n    <style>\r\n        li {\r\n            border-bottom: 1px solid rgb(189, 189, 189);\r\n            border-left: 1px solid rgb(189, 189, 189);\r\n            padding: .5em;\r\n        }\r\n        label {\r\n            display: inline-block;\r\n            width: 8em;\r\n        }\r\n\r\n        h1 span {\r\n            background: yellow;\r\n            border: 2px solid #8e1515;\r\n            padding: 2px 8px;\r\n            margin: 2px 5px;\r\n            border-radius: 7px;\r\n            color: #8e1515;\r\n            display: inline-block;\r\n        }\r\n\r\n        .recordrtc button {\r\n            font-size: inherit;\r\n        }\r\n\r\n        .recordrtc button, .recordrtc select {\r\n            vertical-align: middle;\r\n            line-height: 1;\r\n            padding: 2px 5px;\r\n            height: auto;\r\n            font-size: inherit;\r\n            margin: 0;\r\n        }\r\n\r\n        .recordrtc, .recordrtc .header {\r\n            display: block;\r\n            text-align: center;\r\n            padding-top: 0;\r\n        }\r\n\r\n        .recordrtc video, .recordrtc img {\r\n            max-width: 100%!important;\r\n            vertical-align: top;\r\n        }\r\n\r\n        .recordrtc audio {\r\n            vertical-align: bottom;\r\n        }\r\n\r\n        .recordrtc option[disabled] {\r\n            display: none;\r\n        }\r\n\r\n        .recordrtc select {\r\n            font-size: 17px;\r\n        }\r\n    </style>\r\n\r\n    <script src=\"https://cdn.webrtc-experiment.com/RecordRTC.js\"></script>\r\n\r\n    <!-- web streams API polyfill to support Firefox -->\r\n    <script src=\"https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js\"></script>\r\n\r\n    <!-- ../libs/DBML.js to fix video seeking issues -->\r\n    <script src=\"https://cdn.webrtc-experiment.com/EBML.js\"></script>\r\n\r\n    <!-- for Edge/FF/Chrome/Opera/etc. getUserMedia support -->\r\n    <script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"></script>\r\n    <script src=\"https://cdn.webrtc-experiment.com/DetectRTC.js\"> </script>\r\n\r\n    <!-- video element -->\r\n    <link href=\"https://cdn.webrtc-experiment.com/getHTMLMediaElement.css\" rel=\"stylesheet\">\r\n    <script src=\"https://cdn.webrtc-experiment.com/getHTMLMediaElement.js\"></script>","body":"","js":"\nTemplate.body.addContent((function() {\n  var view = this;\n  return HTML.ARTICLE(HTML.Raw('\\n\\n        <div class=\"github-stargazers\" style=\"margin-top: 25px;\"></div>\\n\\n        <section class=\"experiment recordrtc\">\\n            <h2 class=\"header\" style=\"margin: 0;\">\\n                <select class=\"recording-media\">\\n                    <option value=\"record-audio-plus-video\">Microphone+Camera</option>\\n                    <option value=\"record-audio\">Microphone</option>\\n                    <option value=\"record-screen\">Full Screen</option>\\n                    <option value=\"record-audio-plus-screen\">Microphone+Screen</option>\\n                </select>\\n\\n                <span style=\"font-size: 15px;\">into</span>\\n\\n                <select class=\"media-container-format\">\\n                    <option>default</option>\\n                    <option>vp8</option>\\n                    <option>vp9</option>\\n                    <option>h264</option>\\n                    <option>mkv</option>\\n                    <option>opus</option>\\n                    <option>ogg</option>\\n                    <option>pcm</option>\\n                    <option>gif</option>\\n                    <option>whammy</option>\\n                    <option>WebAssembly</option>\\n                </select>\\n\\n                <input type=\"checkbox\" id=\"chk-timeSlice\" style=\"margin:0;width:auto;\" title=\"Use intervals based recording\">\\n                <label for=\"chk-timeSlice\" style=\"font-size: 15px;margin:0;width: auto;cursor: pointer;-webkit-user-select:none;user-select:none;\" title=\"Use intervals based recording\">Use timeSlice?</label>\\n\\n                <br>\\n\\n                <button id=\"btn-start-recording\">Start Recording</button>\\n                <button id=\"btn-pause-recording\" style=\"display: none; font-size: 15px;\">Pause</button>\\n\\n                <div style=\"display: inline-block;\">\\n                    <input type=\"checkbox\" id=\"chk-fixSeeking\" style=\"margin:0;width:auto;\" title=\"Fix video seeking issues?\">\\n                    <label for=\"chk-fixSeeking\" style=\"font-size: 15px;margin:0;width: auto;cursor: pointer;-webkit-user-select:none;user-select:none;\" title=\"Fix video seeking issues?\">Fix Seeking Issues?</label>\\n                </div>\\n\\n                <hr style=\"border-top: 0;border-bottom: 1px solid rgb(189, 189, 189);margin: 4px -12px;margin-top: 8px;\">\\n                <select class=\"media-resolutions\">\\n                    <option value=\"default\">Default resolutions</option>\\n                    <option value=\"1920x1080\">1080p</option>\\n                    <option value=\"1280x720\">720p</option>\\n                    <option value=\"640x480\">480p</option>\\n                    <option value=\"3840x2160\">4K Ultra HD (3840x2160)</option>\\n                </select>\\n\\n                <select class=\"media-framerates\">\\n                    <option value=\"default\">Default framerates</option>\\n                    <option value=\"5\">5 fps</option>\\n                    <option value=\"15\">15 fps</option>\\n                    <option value=\"24\">24 fps</option>\\n                    <option value=\"30\">30 fps</option>\\n                    <option value=\"60\">60 fps</option>\\n                </select>\\n\\n                <select class=\"media-bitrates\">\\n                    <option value=\"default\">Default bitrates</option>\\n                    <option value=\"8000000000\">1 GB bps</option>\\n                    <option value=\"800000000\">100 MB bps</option>\\n                    <option value=\"8000000\">1 MB bps</option>\\n                    <option value=\"800000\">100 KB bps</option>\\n                    <option value=\"8000\">1 KB bps</option>\\n                    <option value=\"800\">100 Bytes bps</option>\\n                </select>\\n            </h2>\\n\\n            <div style=\"text-align: center; display: none;\">\\n                <button id=\"save-to-disk\">Save To Disk</button>\\n                <button id=\"upload-to-php\">Upload to PHP</button>\\n                <button id=\"open-new-tab\">Open New Tab</button>\\n\\n                <div style=\"margin-top: 10px;\">\\n                    <span id=\"signinButton\" class=\"pre-sign-in\">\\n                      <span class=\"g-signin\" data-callback=\"signinCallback\" data-clientid=\"41556190767-115ifahd55lk4ln5pop4jus55cr4l7oh.apps.googleusercontent.com\" data-cookiepolicy=\"single_host_origin\" data-scope=\"https://www.googleapis.com/auth/youtube.upload https://www.googleapis.com/auth/youtube\">\\n                      </span>\\n                    </span>\\n\\n                    <button id=\"upload-to-youtube\" style=\"vertical-align:top;\">Upload to YouTube</button>\\n                </div>\\n            </div>\\n\\n            <div style=\"margin-top: 10px;\" id=\"recording-player\"></div>\\n        </section>\\n\\n        '), HTML.SCRIPT(\"\\n            (function() {\\n                var params = {},\\n                    r = /([^&=]+)=?([^&]*)/g;\\n\\n                function d(s) {\\n                    return decodeURIComponent(s.replace(/\\\\+/g, ' '));\\n                }\\n\\n                var match, search = window.location.search;\\n                while (match = r.exec(search.substring(1))) {\\n                    params[d(match[1])] = d(match[2]);\\n\\n                    if(d(match[2]) === 'true' || d(match[2]) === 'false') {\\n                        params[d(match[1])] = d(match[2]) === 'true' ? true : false;\\n                    }\\n                }\\n                window.params = params;\\n            })();\\n\\n            function addStreamStopListener(stream, callback) {\\n                stream.addEventListener('ended', function() {\\n                    callback();\\n                    callback = function() {};\\n                }, false);\\n                stream.addEventListener('inactive', function() {\\n                    callback();\\n                    callback = function() {};\\n                }, false);\\n                stream.getTracks().forEach(function(track) {\\n                    track.addEventListener('ended', function() {\\n                        callback();\\n                        callback = function() {};\\n                    }, false);\\n                    track.addEventListener('inactive', function() {\\n                        callback();\\n                        callback = function() {};\\n                    }, false);\\n                });\\n            }\\n        \"), \"\\n\\n        \", HTML.SCRIPT(\"\\n            var video = document.createElement('video');\\n            video.controls = false;\\n            var mediaElement = getHTMLMediaElement(video, {\\n                title: 'Recording status: inactive',\\n                buttons: ['full-screen'/*, 'take-snapshot'*/],\\n                showOnMouseEnter: false,\\n                width: 360,\\n                onTakeSnapshot: function() {\\n                    var canvas = document.createElement('canvas');\\n                    canvas.width = mediaElement.clientWidth;\\n                    canvas.height = mediaElement.clientHeight;\\n\\n                    var context = canvas.getContext('2d');\\n                    context.drawImage(recordingPlayer, 0, 0, canvas.width, canvas.height);\\n\\n                    window.open(canvas.toDataURL('image/png'));\\n                }\\n            });\\n            document.getElementById('recording-player').appendChild(mediaElement);\\n\\n            var div = document.createElement('section');\\n            mediaElement.media.parentNode.appendChild(div);\\n            mediaElement.media.muted = false;\\n            mediaElement.media.autoplay = true;\\n            mediaElement.media.playsinline = true;\\n            div.appendChild(mediaElement.media);\\n\\n            var recordingPlayer = mediaElement.media;\\n            var recordingMedia = document.querySelector('.recording-media');\\n            var mediaContainerFormat = document.querySelector('.media-container-format');\\n            var mimeType = 'video/webm';\\n            var fileExtension = 'webm';\\n            var type = 'video';\\n            var recorderType;\\n            var defaultWidth;\\n            var defaultHeight;\\n\\n            var btnStartRecording = document.querySelector('#btn-start-recording');\\n\\n            window.onbeforeunload = function() {\\n                btnStartRecording.disabled = false;\\n                recordingMedia.disabled = false;\\n                mediaContainerFormat.disabled = false;\\n\\n                chkFixSeeking.parentNode.style.display = 'inline-block';\\n            };\\n\\n            btnStartRecording.onclick = function(event) {\\n                var button = btnStartRecording;\\n\\n                if(button.innerHTML === 'Stop Recording') {\\n                    btnPauseRecording.style.display = 'none';\\n                    button.disabled = true;\\n                    button.disableStateWaiting = true;\\n                    setTimeout(function() {\\n                        button.disabled = false;\\n                        button.disableStateWaiting = false;\\n                    }, 2000);\\n\\n                    button.innerHTML = 'Start Recording';\\n\\n                    function stopStream() {\\n                        if(button.stream && button.stream.stop) {\\n                            button.stream.stop();\\n                            button.stream = null;\\n                        }\\n\\n                        if(button.stream instanceof Array) {\\n                            button.stream.forEach(function(stream) {\\n                                stream.stop();\\n                            });\\n                            button.stream = null;\\n                        }\\n\\n                        videoBitsPerSecond = null;\\n                        var html = 'Recording status: stopped';\\n                        html += '<br>Size: ' + bytesToSize(button.recordRTC.getBlob().size);\\n                        recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = html;\\n                    }\\n\\n                    if(button.recordRTC) {\\n                        if(button.recordRTC.length) {\\n                            button.recordRTC[0].stopRecording(function(url) {\\n                                if(!button.recordRTC[1]) {\\n                                    button.recordingEndedCallback(url);\\n                                    stopStream();\\n\\n                                    saveToDiskOrOpenNewTab(button.recordRTC[0]);\\n                                    return;\\n                                }\\n\\n                                button.recordRTC[1].stopRecording(function(url) {\\n                                    button.recordingEndedCallback(url);\\n                                    stopStream();\\n                                });\\n                            });\\n                        }\\n                        else {\\n                            button.recordRTC.stopRecording(function(url) {\\n                                if(button.blobs && button.blobs.length) {\\n                                    var blob = new File(button.blobs, getFileName(fileExtension), {\\n                                        type: mimeType\\n                                    });\\n\\n                                    button.recordRTC.getBlob = function() {\\n                                        return blob;\\n                                    };\\n\\n                                    url = URL.createObjectURL(blob);\\n                                }\\n\\n                                if(chkFixSeeking.checked === true) {\\n                                    // to fix video seeking issues\\n                                    getSeekableBlob(button.recordRTC.getBlob(), function(seekableBlob) {\\n                                        button.recordRTC.getBlob = function() {\\n                                            return seekableBlob;\\n                                        };\\n\\n                                        url = URL.createObjectURL(seekableBlob);\\n\\n                                        button.recordingEndedCallback(url);\\n                                        saveToDiskOrOpenNewTab(button.recordRTC);\\n                                        stopStream();\\n                                    })\\n                                    return;\\n                                }\\n\\n                                button.recordingEndedCallback(url);\\n                                saveToDiskOrOpenNewTab(button.recordRTC);\\n                                stopStream();\\n                            });\\n                        }\\n                    }\\n                    return;\\n                }\\n                if(!event) return;\\n\\n                button.disabled = true;\\n\\n                var commonConfig = {\\n                    onMediaCaptured: function(stream) {\\n                        button.stream = stream;\\n                        if(button.mediaCapturedCallback) {\\n                            button.mediaCapturedCallback();\\n                        }\\n\\n                        button.innerHTML = 'Stop Recording';\\n                        button.disabled = false;\\n\\n                        chkFixSeeking.parentNode.style.display = 'none';\\n                    },\\n                    onMediaStopped: function() {\\n                        button.innerHTML = 'Start Recording';\\n\\n                        if(!button.disableStateWaiting) {\\n                            button.disabled = false;\\n                        }\\n\\n                        chkFixSeeking.parentNode.style.display = 'inline-block';\\n                    },\\n                    onMediaCapturingFailed: function(error) {\\n                        console.error('onMediaCapturingFailed:', error);\\n\\n                        if(error.toString().indexOf('no audio or video tracks available') !== -1) {\\n                            alert('RecordRTC failed to start because there are no audio or video tracks available.');\\n                        }\\n\\n                        if(error.name === 'PermissionDeniedError' && DetectRTC.browser.name === 'Firefox') {\\n                            alert('Firefox requires version >= 52. Firefox also requires HTTPs.');\\n                        }\\n\\n                        commonConfig.onMediaStopped();\\n                    }\\n                };\\n\\n                if(mediaContainerFormat.value === 'h264') {\\n                    mimeType = 'video/webm\\\\;codecs=h264';\\n                    fileExtension = 'mp4';\\n\\n                    // video/mp4;codecs=avc1\\n                    if(isMimeTypeSupported('video/mpeg')) {\\n                        mimeType = 'video/mpeg';\\n                    }\\n                }\\n\\n                if(mediaContainerFormat.value === 'mkv' && isMimeTypeSupported('video/x-matroska;codecs=avc1')) {\\n                    mimeType = 'video/x-matroska;codecs=avc1';\\n                    fileExtension = 'mkv';\\n                }\\n\\n                if(mediaContainerFormat.value === 'vp8' && isMimeTypeSupported('video/webm\\\\;codecs=vp8')) {\\n                    mimeType = 'video/webm\\\\;codecs=vp8';\\n                    fileExtension = 'webm';\\n                    recorderType = null;\\n                    type = 'video';\\n                }\\n\\n                if(mediaContainerFormat.value === 'vp9' && isMimeTypeSupported('video/webm\\\\;codecs=vp9')) {\\n                    mimeType = 'video/webm\\\\;codecs=vp9';\\n                    fileExtension = 'webm';\\n                    recorderType = null;\\n                    type = 'video';\\n                }\\n\\n                if(mediaContainerFormat.value === 'pcm') {\\n                    mimeType = 'audio/wav';\\n                    fileExtension = 'wav';\\n                    recorderType = StereoAudioRecorder;\\n                    type = 'audio';\\n                }\\n\\n                if(mediaContainerFormat.value === 'opus' || mediaContainerFormat.value === 'ogg') {\\n                    if(isMimeTypeSupported('audio/webm')) {\\n                        mimeType = 'audio/webm';\\n                        fileExtension = 'webm'; // webm\\n                    }\\n\\n                    if(isMimeTypeSupported('audio/ogg')) {\\n                        mimeType = 'audio/ogg; codecs=opus';\\n                        fileExtension = 'ogg'; // ogg\\n                    }\\n\\n                    recorderType = null;\\n                    type = 'audio';\\n                }\\n\\n                if(mediaContainerFormat.value === 'whammy') {\\n                    mimeType = 'video/webm';\\n                    fileExtension = 'webm';\\n                    recorderType = WhammyRecorder;\\n                    type = 'video';\\n                }\\n\\n                if(mediaContainerFormat.value === 'WebAssembly') {\\n                    mimeType = 'video/webm';\\n                    fileExtension = 'webm';\\n                    recorderType = WebAssemblyRecorder;\\n                    type = 'video';\\n                }\\n\\n                if(mediaContainerFormat.value === 'gif') {\\n                    mimeType = 'image/gif';\\n                    fileExtension = 'gif';\\n                    recorderType = GifRecorder;\\n                    type = 'gif';\\n                }\\n\\n                if(mediaContainerFormat.value === 'default') {\\n                    mimeType = 'video/webm';\\n                    fileExtension = 'webm';\\n                    recorderType = null;\\n                    type = 'video';\\n                }\\n\\n                if(recordingMedia.value === 'record-audio') {\\n                    captureAudio(commonConfig);\\n\\n                    button.mediaCapturedCallback = function() {\\n                        var options = {\\n                            type: type,\\n                            mimeType: mimeType,\\n                            leftChannel: params.leftChannel || false,\\n                            disableLogs: params.disableLogs || false\\n                        };\\n\\n                        if(params.sampleRate) {\\n                            options.sampleRate = parseInt(params.sampleRate);\\n                        }\\n\\n                        if(params.bufferSize) {\\n                            options.bufferSize = parseInt(params.bufferSize);\\n                        }\\n\\n                        if(recorderType) {\\n                            options.recorderType = recorderType;\\n                        }\\n\\n                        if(videoBitsPerSecond) {\\n                            options.videoBitsPerSecond = videoBitsPerSecond;\\n                        }\\n\\n                        if(DetectRTC.browser.name === 'Edge') {\\n                            options.numberOfAudioChannels = 1;\\n                        }\\n\\n                        options.ignoreMutedMedia = false;\\n                        button.recordRTC = RecordRTC(button.stream, options);\\n\\n                        button.recordingEndedCallback = function(url) {\\n                            setVideoURL(url);\\n                        };\\n\\n                        button.recordRTC.startRecording();\\n                        btnPauseRecording.style.display = '';\\n                    };\\n                }\\n\\n                if(recordingMedia.value === 'record-audio-plus-video') {\\n                    captureAudioPlusVideo(commonConfig);\\n\\n                    button.mediaCapturedCallback = function() {\\n                        if(typeof MediaRecorder === 'undefined') { // opera or chrome etc.\\n                            button.recordRTC = [];\\n\\n                            if(!params.bufferSize) {\\n                                // it fixes audio issues whilst recording 720p\\n                                params.bufferSize = 16384;\\n                            }\\n\\n                            var options = {\\n                                type: 'audio', // hard-code to set \\\"audio\\\"\\n                                leftChannel: params.leftChannel || false,\\n                                disableLogs: params.disableLogs || false,\\n                                video: recordingPlayer\\n                            };\\n\\n                            if(params.sampleRate) {\\n                                options.sampleRate = parseInt(params.sampleRate);\\n                            }\\n\\n                            if(params.bufferSize) {\\n                                options.bufferSize = parseInt(params.bufferSize);\\n                            }\\n\\n                            if(params.frameInterval) {\\n                                options.frameInterval = parseInt(params.frameInterval);\\n                            }\\n\\n                            if(recorderType) {\\n                                options.recorderType = recorderType;\\n                            }\\n\\n                            if(videoBitsPerSecond) {\\n                                options.videoBitsPerSecond = videoBitsPerSecond;\\n                            }\\n\\n                            options.ignoreMutedMedia = false;\\n                            var audioRecorder = RecordRTC(button.stream, options);\\n\\n                            options.type = type;\\n                            var videoRecorder = RecordRTC(button.stream, options);\\n\\n                            // to sync audio/video playbacks in browser!\\n                            videoRecorder.initRecorder(function() {\\n                                audioRecorder.initRecorder(function() {\\n                                    audioRecorder.startRecording();\\n                                    videoRecorder.startRecording();\\n                                    btnPauseRecording.style.display = '';\\n                                });\\n                            });\\n\\n                            button.recordRTC.push(audioRecorder, videoRecorder);\\n\\n                            button.recordingEndedCallback = function() {\\n                                var audio = new Audio();\\n                                audio.src = audioRecorder.toURL();\\n                                audio.controls = true;\\n                                audio.autoplay = true;\\n\\n                                recordingPlayer.parentNode.appendChild(document.createElement('hr'));\\n                                recordingPlayer.parentNode.appendChild(audio);\\n\\n                                if(audio.paused) audio.play();\\n                            };\\n                            return;\\n                        }\\n\\n                        var options = {\\n                            type: type,\\n                            mimeType: mimeType,\\n                            disableLogs: params.disableLogs || false,\\n                            getNativeBlob: false, // enable it for longer recordings\\n                            video: recordingPlayer\\n                        };\\n\\n                        if(recorderType) {\\n                            options.recorderType = recorderType;\\n\\n                            if(recorderType == WhammyRecorder || recorderType == GifRecorder || recorderType == WebAssemblyRecorder) {\\n                                options.canvas = options.video = {\\n                                    width: defaultWidth || 320,\\n                                    height: defaultHeight || 240\\n                                };\\n                            }\\n                        }\\n\\n                        if(videoBitsPerSecond) {\\n                            options.videoBitsPerSecond = videoBitsPerSecond;\\n                        }\\n\\n                        if(timeSlice && typeof MediaRecorder !== 'undefined') {\\n                            options.timeSlice = timeSlice;\\n                            button.blobs = [];\\n                            options.ondataavailable = function(blob) {\\n                                button.blobs.push(blob);\\n                            };\\n                        }\\n\\n                        options.ignoreMutedMedia = false;\\n                        button.recordRTC = RecordRTC(button.stream, options);\\n\\n                        button.recordingEndedCallback = function(url) {\\n                            setVideoURL(url);\\n                        };\\n\\n                        button.recordRTC.startRecording();\\n                        btnPauseRecording.style.display = '';\\n                        recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = '<img src=\\\"https://cdn.webrtc-experiment.com/images/progress.gif\\\">';\\n                    };\\n                }\\n\\n                if(recordingMedia.value === 'record-screen') {\\n                    captureScreen(commonConfig);\\n\\n                    button.mediaCapturedCallback = function() {\\n                        var options = {\\n                            type: type,\\n                            mimeType: mimeType,\\n                            disableLogs: params.disableLogs || false,\\n                            getNativeBlob: false, // enable it for longer recordings\\n                            video: recordingPlayer\\n                        };\\n\\n                        if(recorderType) {\\n                            options.recorderType = recorderType;\\n\\n                            if(recorderType == WhammyRecorder || recorderType == GifRecorder || recorderType == WebAssemblyRecorder) {\\n                                options.canvas = options.video = {\\n                                    width: defaultWidth || 320,\\n                                    height: defaultHeight || 240\\n                                };\\n                            }\\n                        }\\n\\n                        if(videoBitsPerSecond) {\\n                            options.videoBitsPerSecond = videoBitsPerSecond;\\n                        }\\n\\n                        options.ignoreMutedMedia = false;\\n                        button.recordRTC = RecordRTC(button.stream, options);\\n\\n                        button.recordingEndedCallback = function(url) {\\n                            setVideoURL(url);\\n                        };\\n\\n                        button.recordRTC.startRecording();\\n                        btnPauseRecording.style.display = '';\\n                    };\\n                }\\n\\n                // note: audio+tab is supported in Chrome 50+\\n                // todo: add audio+tab recording\\n                if(recordingMedia.value === 'record-audio-plus-screen') {\\n                    captureAudioPlusScreen(commonConfig);\\n\\n                    button.mediaCapturedCallback = function() {\\n                        var options = {\\n                            type: type,\\n                            mimeType: mimeType,\\n                            disableLogs: params.disableLogs || false,\\n                            getNativeBlob: false, // enable it for longer recordings\\n                            video: recordingPlayer\\n                        };\\n\\n                        if(recorderType) {\\n                            options.recorderType = recorderType;\\n\\n                            if(recorderType == WhammyRecorder || recorderType == GifRecorder || recorderType == WebAssemblyRecorder) {\\n                                options.canvas = options.video = {\\n                                    width: defaultWidth || 320,\\n                                    height: defaultHeight || 240\\n                                };\\n                            }\\n                        }\\n\\n                        if(videoBitsPerSecond) {\\n                            options.videoBitsPerSecond = videoBitsPerSecond;\\n                        }\\n\\n                        options.ignoreMutedMedia = false;\\n                        button.recordRTC = RecordRTC(button.stream, options);\\n\\n                        button.recordingEndedCallback = function(url) {\\n                            setVideoURL(url);\\n                        };\\n\\n                        button.recordRTC.startRecording();\\n                        btnPauseRecording.style.display = '';\\n                    };\\n                }\\n            };\\n\\n            function captureVideo(config) {\\n                captureUserMedia({video: true}, function(videoStream) {\\n                    config.onMediaCaptured(videoStream);\\n\\n                    addStreamStopListener(videoStream, function() {\\n                        config.onMediaStopped();\\n                    });\\n                }, function(error) {\\n                    config.onMediaCapturingFailed(error);\\n                });\\n            }\\n\\n            function captureAudio(config) {\\n                captureUserMedia({audio: true}, function(audioStream) {\\n                    config.onMediaCaptured(audioStream);\\n\\n                    addStreamStopListener(audioStream, function() {\\n                        config.onMediaStopped();\\n                    });\\n                }, function(error) {\\n                    config.onMediaCapturingFailed(error);\\n                });\\n            }\\n\\n            function captureAudioPlusVideo(config) {\\n                captureUserMedia({video: true, audio: true}, function(audioVideoStream) {\\n                    config.onMediaCaptured(audioVideoStream);\\n\\n                    if(audioVideoStream instanceof Array) {\\n                        audioVideoStream.forEach(function(stream) {\\n                            addStreamStopListener(stream, function() {\\n                                config.onMediaStopped();\\n                            });\\n                        });\\n                        return;\\n                    }\\n\\n                    addStreamStopListener(audioVideoStream, function() {\\n                        config.onMediaStopped();\\n                    });\\n                }, function(error) {\\n                    config.onMediaCapturingFailed(error);\\n                });\\n            }\\n\\n            var MY_DOMAIN = 'webrtc-experiment.com';\\n\\n            function isMyOwnDomain() {\\n                // replace \\\"webrtc-experiment.com\\\" with your own domain name\\n                return document.domain.indexOf(MY_DOMAIN) !== -1;\\n            }\\n\\n            function isLocalHost() {\\n                // \\\"chrome.exe\\\" --enable-usermedia-screen-capturing\\n                // or firefox => about:config => \\\"media.getusermedia.screensharing.allowed_domains\\\" => add \\\"localhost\\\"\\n                return document.domain === 'localhost' || document.domain === 'http://127.0.0.1:3000/';\\n            }\\n\\n            var videoBitsPerSecond;\\n\\n            function setVideoBitrates() {\\n                var select = document.querySelector('.media-bitrates');\\n                var value = select.value;\\n\\n                if(value == 'default') {\\n                    videoBitsPerSecond = null;\\n                    return;\\n                }\\n\\n                videoBitsPerSecond = parseInt(value);\\n            }\\n\\n            function getFrameRates(mediaConstraints) {\\n                if(!mediaConstraints.video) {\\n                    return mediaConstraints;\\n                }\\n\\n                var select = document.querySelector('.media-framerates');\\n                var value = select.value;\\n\\n                if(value == 'default') {\\n                    return mediaConstraints;\\n                }\\n\\n                value = parseInt(value);\\n\\n                if(DetectRTC.browser.name === 'Firefox') {\\n                    mediaConstraints.video.frameRate = value;\\n                    return mediaConstraints;\\n                }\\n\\n                if(!mediaConstraints.video.mandatory) {\\n                    mediaConstraints.video.mandatory = {};\\n                    mediaConstraints.video.optional = [];\\n                }\\n\\n                var isScreen = recordingMedia.value.toString().toLowerCase().indexOf('screen') != -1;\\n                if(isScreen) {\\n                    mediaConstraints.video.mandatory.maxFrameRate = value;\\n                }\\n                else {\\n                    mediaConstraints.video.mandatory.minFrameRate = value;\\n                }\\n\\n                return mediaConstraints;\\n            }\\n\\n            function setGetFromLocalStorage(selectors) {\\n                selectors.forEach(function(selector) {\\n                    var storageItem = selector.replace(/\\\\.|#/g, '');\\n                    if(localStorage.getItem(storageItem)) {\\n                        document.querySelector(selector).value = localStorage.getItem(storageItem);\\n                    }\\n\\n                    addEventListenerToUploadLocalStorageItem(selector, ['change', 'blur'], function() {\\n                        localStorage.setItem(storageItem, document.querySelector(selector).value);\\n                    });\\n                });\\n            }\\n\\n            function addEventListenerToUploadLocalStorageItem(selector, arr, callback) {\\n                arr.forEach(function(event) {\\n                    document.querySelector(selector).addEventListener(event, callback, false);\\n                });\\n            }\\n\\n            setGetFromLocalStorage(['.media-resolutions', '.media-framerates', '.media-bitrates', '.recording-media', '.media-container-format']);\\n\\n            function getVideoResolutions(mediaConstraints) {\\n                if(!mediaConstraints.video) {\\n                    return mediaConstraints;\\n                }\\n\\n                var select = document.querySelector('.media-resolutions');\\n                var value = select.value;\\n\\n                if(value == 'default') {\\n                    return mediaConstraints;\\n                }\\n\\n                value = value.split('x');\\n\\n                if(value.length != 2) {\\n                    return mediaConstraints;\\n                }\\n\\n                defaultWidth = parseInt(value[0]);\\n                defaultHeight = parseInt(value[1]);\\n\\n                if(DetectRTC.browser.name === 'Firefox') {\\n                    mediaConstraints.video.width = defaultWidth;\\n                    mediaConstraints.video.height = defaultHeight;\\n                    return mediaConstraints;\\n                }\\n\\n                if(!mediaConstraints.video.mandatory) {\\n                    mediaConstraints.video.mandatory = {};\\n                    mediaConstraints.video.optional = [];\\n                }\\n\\n                var isScreen = recordingMedia.value.toString().toLowerCase().indexOf('screen') != -1;\\n\\n                if(isScreen) {\\n                    mediaConstraints.video.mandatory.maxWidth = defaultWidth;\\n                    mediaConstraints.video.mandatory.maxHeight = defaultHeight;\\n                }\\n                else {\\n                    mediaConstraints.video.mandatory.minWidth = defaultWidth;\\n                    mediaConstraints.video.mandatory.minHeight = defaultHeight;\\n                }\\n\\n                return mediaConstraints;\\n            }\\n\\n            function captureUserMedia(mediaConstraints, successCallback, errorCallback) {\\n                if(mediaConstraints.video == true) {\\n                    mediaConstraints.video = {};\\n                }\\n\\n                setVideoBitrates();\\n\\n                mediaConstraints = getVideoResolutions(mediaConstraints);\\n                mediaConstraints = getFrameRates(mediaConstraints);\\n\\n                var isBlackBerry = !!(/BB10|BlackBerry/i.test(navigator.userAgent || ''));\\n                if(isBlackBerry && !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia)) {\\n                    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\\n                    navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);\\n                    return;\\n                }\\n\\n                navigator.mediaDevices.getUserMedia(mediaConstraints).then(function(stream) {\\n                    successCallback(stream);\\n\\n                    setVideoURL(stream, true);\\n                }).catch(function(error) {\\n                    if(error && (error.name === 'ConstraintNotSatisfiedError' || error.name === 'OverconstrainedError')) {\\n                        alert('Your camera or browser does NOT supports selected resolutions or frame-rates. \\\\n\\\\nPlease select \\\"default\\\" resolutions.');\\n                    }\\n                    else if(error && error.message) {\\n                        alert(error.message);\\n                    }\\n                    else {\\n                        alert('Unable to make getUserMedia request. Please check browser console logs.');\\n                    }\\n\\n                    errorCallback(error);\\n                });\\n            }\\n\\n            function setMediaContainerFormat(arrayOfOptionsSupported) {\\n                var options = Array.prototype.slice.call(\\n                    mediaContainerFormat.querySelectorAll('option')\\n                );\\n\\n                var localStorageItem;\\n                if(localStorage.getItem('media-container-format')) {\\n                    localStorageItem = localStorage.getItem('media-container-format');\\n                }\\n\\n                var selectedItem;\\n                options.forEach(function(option) {\\n                    option.disabled = true;\\n\\n                    if(arrayOfOptionsSupported.indexOf(option.value) !== -1) {\\n                        option.disabled = false;\\n\\n                        if(localStorageItem && arrayOfOptionsSupported.indexOf(localStorageItem) != -1) {\\n                            if(option.value != localStorageItem) return;\\n                            option.selected = true;\\n                            selectedItem = option;\\n                            return;\\n                        }\\n\\n                        if(!selectedItem) {\\n                            option.selected = true;\\n                            selectedItem = option;\\n                        }\\n                    }\\n                });\\n            }\\n\\n            function isMimeTypeSupported(mimeType) {\\n                if(typeof MediaRecorder === 'undefined') {\\n                    return false;\\n                }\\n\\n                if(typeof MediaRecorder.isTypeSupported !== 'function') {\\n                    return true;\\n                }\\n\\n                return MediaRecorder.isTypeSupported(mimeType);\\n            }\\n\\n            recordingMedia.onchange = function() {\\n                if(recordingMedia.value === 'record-audio') {\\n                    var recordingOptions = [];\\n\\n                    if(isMimeTypeSupported('audio/webm')) {\\n                        recordingOptions.push('opus');\\n                    }\\n\\n                    if(isMimeTypeSupported('audio/ogg')) {\\n                        recordingOptions.push('ogg');\\n                    }\\n\\n                    recordingOptions.push('pcm');\\n\\n                    setMediaContainerFormat(recordingOptions);\\n                    return;\\n                }\\n\\n                var isChrome = !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0);\\n\\n                var recordingOptions = ['vp8']; // MediaStreamRecorder with vp8\\n\\n                if(isMimeTypeSupported('video/webm\\\\;codecs=vp9')) {\\n                    recordingOptions.push('vp9'); // MediaStreamRecorder with vp9\\n                }\\n\\n                if(isMimeTypeSupported('video/webm\\\\;codecs=h264')) {\\n                    recordingOptions.push('h264'); // MediaStreamRecorder with h264\\n                }\\n\\n                if(isMimeTypeSupported('video/x-matroska;codecs=avc1')) {\\n                    recordingOptions.push('mkv'); // MediaStreamRecorder with mkv/matroska\\n                }\\n\\n                recordingOptions.push('gif'); // GifRecorder\\n\\n                if(DetectRTC.browser.name == 'Chrome') {\\n                    recordingOptions.push('whammy'); // WhammyRecorder\\n                }\\n\\n                if(DetectRTC.browser.name == 'Chrome') {\\n                    recordingOptions.push('WebAssembly'); // WebAssemblyRecorder\\n                }\\n\\n                recordingOptions.push('default'); // Default mimeType for MediaStreamRecorder\\n\\n                setMediaContainerFormat(recordingOptions);\\n            };\\n            recordingMedia.onchange();\\n\\n            if(typeof MediaRecorder === 'undefined' && (DetectRTC.browser.name === 'Edge' || DetectRTC.browser.name === 'Safari')) {\\n                // webp isn't supported in Microsoft Edge\\n                // neither MediaRecorder API\\n                // so lets disable both video/screen recording options\\n\\n                console.warn('Neither MediaRecorder API nor webp is supported in ' + DetectRTC.browser.name + '. You cam merely record audio.');\\n\\n                recordingMedia.innerHTML = '<option value=\\\"record-audio\\\">Audio</option>';\\n                setMediaContainerFormat(['pcm']);\\n            }\\n\\n            function stringify(obj) {\\n                var result = '';\\n                Object.keys(obj).forEach(function(key) {\\n                    if(typeof obj[key] === 'function') {\\n                        return;\\n                    }\\n\\n                    if(result.length) {\\n                        result += ',';\\n                    }\\n\\n                    result += key + ': ' + obj[key];\\n                });\\n\\n                return result;\\n            }\\n\\n            function mediaRecorderToStringify(mediaRecorder) {\\n                var result = '';\\n                result += 'mimeType: ' + mediaRecorder.mimeType;\\n                result += ', state: ' + mediaRecorder.state;\\n                result += ', audioBitsPerSecond: ' + mediaRecorder.audioBitsPerSecond;\\n                result += ', videoBitsPerSecond: ' + mediaRecorder.videoBitsPerSecond;\\n                if(mediaRecorder.stream) {\\n                    result += ', streamid: ' + mediaRecorder.stream.id;\\n                    result += ', stream-active: ' + mediaRecorder.stream.active;\\n                }\\n                return result;\\n            }\\n\\n            function getFailureReport() {\\n                var info = 'RecordRTC seems failed. \\\\n\\\\n' + stringify(DetectRTC.browser) + '\\\\n\\\\n' + DetectRTC.osName + ' ' + DetectRTC.osVersion + '\\\\n';\\n\\n                if (typeof recorderType !== 'undefined' && recorderType) {\\n                    info += '\\\\nrecorderType: ' + recorderType.name;\\n                }\\n\\n                if (typeof mimeType !== 'undefined') {\\n                    info += '\\\\nmimeType: ' + mimeType;\\n                }\\n\\n                Array.prototype.slice.call(document.querySelectorAll('select')).forEach(function(select) {\\n                    info += '\\\\n' + (select.id || select.className) + ': ' + select.value;\\n                });\\n\\n                if (btnStartRecording.recordRTC) {\\n                    info += '\\\\n\\\\ninternal-recorder: ' + btnStartRecording.recordRTC.getInternalRecorder().name;\\n\\n                    if(btnStartRecording.recordRTC.getInternalRecorder().getAllStates) {\\n                        info += '\\\\n\\\\nrecorder-states: ' + btnStartRecording.recordRTC.getInternalRecorder().getAllStates();\\n                    }\\n                }\\n\\n                if(btnStartRecording.stream) {\\n                    info += '\\\\n\\\\naudio-tracks: ' + getTracks(btnStartRecording.stream, 'audio').length;\\n                    info += '\\\\nvideo-tracks: ' + getTracks(btnStartRecording.stream, 'video').length;\\n                    info += '\\\\nstream-active? ' + !!btnStartRecording.stream.active;\\n\\n                    btnStartRecording.stream.getTracks().forEach(function(track) {\\n                        info += '\\\\n' + track.kind + '-track-' + (track.label || track.id) + ': (enabled: ' + !!track.enabled + ', readyState: ' + track.readyState + ', muted: ' + !!track.muted + ')';\\n\\n                        if(track.getConstraints && Object.keys(track.getConstraints()).length) {\\n                            info += '\\\\n' + track.kind + '-track-getConstraints: ' + stringify(track.getConstraints());\\n                        }\\n\\n                        if(track.getSettings && Object.keys(track.getSettings()).length) {\\n                            info += '\\\\n' + track.kind + '-track-getSettings: ' + stringify(track.getSettings());\\n                        }\\n                    });\\n                }\\n\\n                if(timeSlice && btnStartRecording.recordRTC) {\\n                    info += '\\\\ntimeSlice: ' + timeSlice;\\n\\n                    if(btnStartRecording.recordRTC.getInternalRecorder().getArrayOfBlobs) {\\n                        var blobSizes = [];\\n                        btnStartRecording.recordRTC.getInternalRecorder().getArrayOfBlobs().forEach(function(blob) {\\n                            blobSizes.push(blob.size);\\n                        });\\n                        info += '\\\\nblobSizes: ' + blobSizes;\\n                    }\\n                }\\n\\n                else if(btnStartRecording.recordRTC && btnStartRecording.recordRTC.getBlob()) {\\n                    info += '\\\\n\\\\nblobSize: ' + bytesToSize(btnStartRecording.recordRTC.getBlob().size);\\n                }\\n\\n                if(btnStartRecording.recordRTC && btnStartRecording.recordRTC.getInternalRecorder() && btnStartRecording.recordRTC.getInternalRecorder().getInternalRecorder && btnStartRecording.recordRTC.getInternalRecorder().getInternalRecorder()) {\\n                    info += '\\\\n\\\\ngetInternalRecorder: ' + mediaRecorderToStringify(btnStartRecording.recordRTC.getInternalRecorder().getInternalRecorder());\\n                }\\n\\n                return info;\\n            }\\n\\n            function saveToDiskOrOpenNewTab(recordRTC) {\\n                if(!recordRTC.getBlob().size) {\\n                    var info = getFailureReport();\\n                    console.log('blob', recordRTC.getBlob());\\n                    console.log('recordrtc instance', recordRTC);\\n                    console.log('report', info);\\n\\n                    if(mediaContainerFormat.value !== 'default') {\\n                        alert('RecordRTC seems failed recording using ' + mediaContainerFormat.value + '. Please choose \\\"default\\\" option from the drop down and record again.');\\n                    }\\n                    else {\\n                        alert('RecordRTC seems failed. Unexpected issue. You can read the email in your console log. \\\\n\\\\nPlease report using disqus chat below.');\\n                    }\\n\\n                    if(mediaContainerFormat.value !== 'vp9' && DetectRTC.browser.name === 'Chrome') {\\n                        alert('Please record using VP9 encoder. (select from the dropdown)');\\n                    }\\n                }\\n\\n                var fileName = getFileName(fileExtension);\\n\\n                document.querySelector('#save-to-disk').parentNode.style.display = 'block';\\n                document.querySelector('#save-to-disk').onclick = function() {\\n                    if(!recordRTC) return alert('No recording found.');\\n\\n                    var file = new File([recordRTC.getBlob()], fileName, {\\n                        type: mimeType\\n                    });\\n\\n                    invokeSaveAsDialog(file, file.name);\\n                };\\n\\n                document.querySelector('#open-new-tab').onclick = function() {\\n                    if(!recordRTC) return alert('No recording found.');\\n\\n                    var file = new File([recordRTC.getBlob()], fileName, {\\n                        type: mimeType\\n                    });\\n\\n                    window.open(URL.createObjectURL(file));\\n                };\\n\\n                // upload to PHP server\\n                if(isMyOwnDomain()) {\\n                    document.querySelector('#upload-to-php').disabled = true;\\n                    document.querySelector('#upload-to-php').style.display = 'none';\\n                }\\n                else {\\n                    document.querySelector('#upload-to-php').disabled = false;\\n                }\\n\\n                document.querySelector('#upload-to-php').onclick = function() {\\n                    if(isMyOwnDomain()) {\\n                        alert('PHP Upload is not available on this domain.');\\n                        return;\\n                    }\\n\\n                    if(!recordRTC) return alert('No recording found.');\\n                    this.disabled = true;\\n\\n                    var button = this;\\n                    uploadToPHPServer(fileName, recordRTC, function(progress, fileURL) {\\n                        if(progress === 'ended') {\\n                            button.disabled = false;\\n                            button.innerHTML = 'Click to download from server';\\n                            button.onclick = function() {\\n                                SaveFileURLToDisk(fileURL, fileName);\\n                            };\\n\\n                            setVideoURL(fileURL);\\n\\n                            var html = 'Uploaded to PHP.<br>Download using below link:<br>';\\n                            html += '<a href=\\\"'+fileURL+'\\\" download=\\\"'+fileName+'\\\" style=\\\"color: yellow; display: block; margin-top: 15px;\\\">'+fileName+'</a>';\\n                            recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = html;\\n                            return;\\n                        }\\n                        button.innerHTML = progress;\\n                        recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = progress;\\n                    });\\n                };\\n\\n                // upload to YouTube!\\n                document.querySelector('#upload-to-youtube').disabled = false;\\n                document.querySelector('#upload-to-youtube').onclick = function() {\\n                    if(!recordRTC) return alert('No recording found.');\\n                    this.disabled = true;\\n\\n                    if(isLocalHost()) {\\n                        alert('This feature is NOT available on localhost.');\\n                        return;\\n                    }\\n\\n                    if(isMyOwnDomain() === false) {\\n                        var url = 'https://github.com/muaz-khan/RecordRTC/wiki/Upload-to-YouTube';\\n                        alert('YouTube API key is configured to work only on webrtc-experiment.com. Please create your own YouTube key + oAuth client-id and use it instead.\\\\n\\\\nWiki page: ' + url);\\n\\n                        // check instructions on the wiki page\\n                        location.href = url;\\n                        return;\\n                    }\\n\\n                    var button = this;\\n                    uploadToYouTube(fileName, recordRTC, function(percentageComplete, fileURL) {\\n                        if(percentageComplete == 'uploaded') {\\n                            button.disabled = false;\\n                            button.innerHTML = 'Uploaded. However YouTube is still processing.';\\n                            button.onclick = function() {\\n                                window.open(fileURL);\\n                            };\\n                            return;\\n                        }\\n                        if(percentageComplete == 'processed') {\\n                            button.disabled = false;\\n                            button.innerHTML = 'Uploaded & Processed. Click to open YouTube video.';\\n                            button.onclick = function() {\\n                                window.open(fileURL);\\n                            };\\n\\n                            document.querySelector('h1').innerHTML = 'Your video has been uploaded.';\\n                            window.scrollTo(0, 0);\\n\\n                            alert('Your video has been uploaded.');\\n                            return;\\n                        }\\n                        if(percentageComplete == 'failed') {\\n                            button.disabled = false;\\n                            button.innerHTML = 'YouTube failed transcoding the video.';\\n                            button.onclick = function() {\\n                                window.open(fileURL);\\n                            };\\n                            return;\\n                        }\\n                        button.innerHTML = percentageComplete + '% uploaded to YouTube.';\\n                    });\\n                };\\n            }\\n\\n            function uploadToPHPServer(fileName, recordRTC, callback) {\\n                var blob = recordRTC instanceof Blob ? recordRTC : recordRTC.getBlob();\\n\\n                blob = new File([blob], getFileName(fileExtension), {\\n                    type: mimeType\\n                });\\n\\n                // create FormData\\n                var formData = new FormData();\\n                formData.append('video-filename', fileName);\\n                formData.append('video-blob', blob);\\n\\n                callback('Uploading recorded-file to server.');\\n\\n                // var upload_url = 'https://your-domain.com/files-uploader/';\\n                var upload_url = 'RecordRTC-to-PHP/save.php';\\n\\n                // var upload_directory = upload_url;\\n                var upload_directory = 'RecordRTC-to-PHP/uploads/';\\n\\n                makeXMLHttpRequest(upload_url, formData, function(progress) {\\n                    if (progress !== 'upload-ended') {\\n                        callback(progress);\\n                        return;\\n                    }\\n\\n                    callback('ended', upload_directory + fileName);\\n                });\\n            }\\n\\n            function makeXMLHttpRequest(url, data, callback) {\\n                var request = new XMLHttpRequest();\\n                request.onreadystatechange = function() {\\n                    if (request.readyState == 4 && request.status == 200) {\\n                        if(request.responseText === 'success') {\\n                            callback('upload-ended');\\n                            return;\\n                        }\\n\\n                        document.querySelector('.header').parentNode.style = 'text-align: left; color: red; padding: 5px 10px;';\\n                        document.querySelector('.header').parentNode.innerHTML = request.responseText;\\n                    }\\n                };\\n\\n                request.upload.onloadstart = function() {\\n                    callback('Upload started...');\\n                };\\n\\n                request.upload.onprogress = function(event) {\\n                    callback('Upload Progress ' + Math.round(event.loaded / event.total * 100) + \\\"%\\\");\\n                };\\n\\n                request.upload.onload = function() {\\n                    callback('progress-about-to-end');\\n                };\\n\\n                request.upload.onload = function() {\\n                    callback('Getting File URL..');\\n                };\\n\\n                request.upload.onerror = function(error) {\\n                    callback('Failed to upload to server');\\n                };\\n\\n                request.upload.onabort = function(error) {\\n                    callback('Upload aborted.');\\n                };\\n\\n                request.open('POST', url);\\n                request.send(data);\\n            }\\n\\n            function getRandomString() {\\n                if (window.crypto && window.crypto.getRandomValues && navigator.userAgent.indexOf('Safari') === -1) {\\n                    var a = window.crypto.getRandomValues(new Uint32Array(3)),\\n                        token = '';\\n                    for (var i = 0, l = a.length; i < l; i++) {\\n                        token += a[i].toString(36);\\n                    }\\n                    return token;\\n                } else {\\n                    return (Math.random() * new Date().getTime()).toString(36).replace(/\\\\./g, '');\\n                }\\n            }\\n\\n            function getFileName(fileExtension) {\\n                var d = new Date();\\n                var year = d.getUTCFullYear();\\n                var month = d.getUTCMonth();\\n                var date = d.getUTCDate();\\n                return 'RecordRTC-' + year + month + date + '-' + getRandomString() + '.' + fileExtension;\\n            }\\n\\n            function SaveFileURLToDisk(fileUrl, fileName) {\\n                var hyperlink = document.createElement('a');\\n                hyperlink.href = fileUrl;\\n                hyperlink.target = '_blank';\\n                hyperlink.download = fileName || fileUrl;\\n\\n                (document.body || document.documentElement).appendChild(hyperlink);\\n                hyperlink.onclick = function() {\\n                   (document.body || document.documentElement).removeChild(hyperlink);\\n\\n                   // required for Firefox\\n                   window.URL.revokeObjectURL(hyperlink.href);\\n                };\\n\\n                var mouseEvent = new MouseEvent('click', {\\n                    view: window,\\n                    bubbles: true,\\n                    cancelable: true\\n                });\\n\\n                hyperlink.dispatchEvent(mouseEvent);\\n            }\\n\\n            function getURL(arg) {\\n                var url = arg;\\n\\n                if(arg instanceof Blob || arg instanceof File) {\\n                    url = URL.createObjectURL(arg);\\n                }\\n\\n                if(arg instanceof RecordRTC || arg.getBlob) {\\n                    url = URL.createObjectURL(arg.getBlob());\\n                }\\n\\n                if(arg instanceof MediaStream || arg.getTracks) {\\n                    // url = URL.createObjectURL(arg);\\n                }\\n\\n                return url;\\n            }\\n\\n            function setVideoURL(arg, forceNonImage) {\\n                var url = getURL(arg);\\n\\n                var parentNode = recordingPlayer.parentNode;\\n                parentNode.removeChild(recordingPlayer);\\n                parentNode.innerHTML = '';\\n\\n                var elem = 'video';\\n                if(type == 'gif' && !forceNonImage) {\\n                    elem = 'img';\\n                }\\n                if(type == 'audio') {\\n                    elem = 'audio';\\n                }\\n\\n                recordingPlayer = document.createElement(elem);\\n\\n                if(arg instanceof MediaStream) {\\n                    recordingPlayer.muted = true;\\n                }\\n\\n                recordingPlayer.addEventListener('loadedmetadata', function() {\\n                    if(navigator.userAgent.toLowerCase().indexOf('android') == -1) return;\\n\\n                    // android\\n                    setTimeout(function() {\\n                        if(typeof recordingPlayer.play === 'function') {\\n                            recordingPlayer.play();\\n                        }\\n                    }, 2000);\\n                }, false);\\n\\n                recordingPlayer.poster = '';\\n\\n                if(arg instanceof MediaStream) {\\n                    recordingPlayer.srcObject = arg;\\n                }\\n                else {\\n                    recordingPlayer.src = url;\\n                }\\n\\n                if(typeof recordingPlayer.play === 'function') {\\n                    recordingPlayer.play();\\n                }\\n\\n                recordingPlayer.addEventListener('ended', function() {\\n                    url = getURL(arg);\\n\\n                    if(arg instanceof MediaStream) {\\n                        recordingPlayer.srcObject = arg;\\n                    }\\n                    else {\\n                        recordingPlayer.src = url;\\n                    }\\n                });\\n\\n                parentNode.appendChild(recordingPlayer);\\n            }\\n        \"), \"\\n\\n        \", HTML.SCRIPT(\"\\n            function captureScreen(config) {\\n                if (navigator.getDisplayMedia) {\\n                    navigator.getDisplayMedia({\\n                        video: true\\n                    }).then(screenStream => {\\n                        config.onMediaCaptured(screenStream);\\n\\n                        addStreamStopListener(screenStream, function() {\\n                            // config.onMediaStopped();\\n\\n                            btnStartRecording.onclick();\\n                        });\\n\\n                        setVideoURL(screenStream, true);\\n                    }).catch(function(error) {\\n                        config.onMediaCapturingFailed(error);\\n                    });\\n                } else if (navigator.mediaDevices.getDisplayMedia) {\\n                    navigator.mediaDevices.getDisplayMedia({\\n                        video: true\\n                    }).then(screenStream => {\\n                        config.onMediaCaptured(screenStream);\\n\\n                        addStreamStopListener(screenStream, function() {\\n                            // config.onMediaStopped();\\n\\n                            btnStartRecording.onclick();\\n                        });\\n\\n                        setVideoURL(screenStream, true);\\n                    }).catch(function(error) {\\n                        config.onMediaCapturingFailed(error);\\n                    });\\n                } else {\\n                    var error = 'getDisplayMedia API are not supported in this browser.';\\n                    config.onMediaCapturingFailed(error);\\n                    alert(error);\\n                }\\n            }\\n\\n            function captureAudioPlusScreen(config) {\\n                if (navigator.getDisplayMedia) {\\n                    navigator.getDisplayMedia({\\n                        video: true\\n                    }).then(screenStream => {\\n                        navigator.mediaDevices.getUserMedia({audio:true}).then(function(mic) {\\n                            screenStream.addTrack(mic.getTracks()[0]);\\n\\n                            config.onMediaCaptured(screenStream);\\n\\n                            addStreamStopListener(screenStream, function() {\\n                                // config.onMediaStopped();\\n\\n                                btnStartRecording.onclick();\\n                            });\\n\\n                            setVideoURL(screenStream, true);\\n                        });\\n                    }).catch(function(error) {\\n                        config.onMediaCapturingFailed(error);\\n                    });\\n                } else if (navigator.mediaDevices.getDisplayMedia) {\\n                    navigator.mediaDevices.getDisplayMedia({\\n                        video: true\\n                    }).then(screenStream => {\\n                        navigator.mediaDevices.getUserMedia({audio:true}).then(function(mic) {\\n                            screenStream.addTrack(mic.getTracks()[0]);\\n\\n                            config.onMediaCaptured(screenStream);\\n\\n                            addStreamStopListener(screenStream, function() {\\n                                // config.onMediaStopped();\\n\\n                                btnStartRecording.onclick();\\n                            });\\n\\n                            setVideoURL(screenStream, true);\\n                        });\\n                    }).catch(function(error) {\\n                        config.onMediaCapturingFailed(error);\\n                    });\\n                } else {\\n                    var error = 'getDisplayMedia API are not supported in this browser.';\\n                    config.onMediaCapturingFailed(error);\\n                    alert(error);\\n                }\\n            }\\n        \"), \"\\n\\n        \", HTML.SCRIPT(\"\\n            /* upload_youtube_video.js Copyright 2017 Google Inc. All Rights Reserved. */\\n\\n            function uploadToYouTube(fileName, recordRTC, callback) {\\n                var blob = recordRTC instanceof Blob ? recordRTC : recordRTC.getBlob();\\n\\n                blob = new File([blob], getFileName(fileExtension), {\\n                    type: mimeType\\n                });\\n\\n                if(!uploadVideo) {\\n                    alert('YouTube API are not available.');\\n                    return;\\n                }\\n\\n                uploadVideo.callback = callback;\\n                uploadVideo.uploadFile(fileName, blob);\\n            }\\n\\n            var uploadVideo;\\n\\n            var signinCallback = function (result){\\n              if(result.access_token) {\\n                uploadVideo = new UploadVideo();\\n                uploadVideo.ready(result.access_token);\\n\\n                document.querySelector('#signinButton').style.display = 'none';\\n              }\\n              else {\\n                // console.error('YouTube error', result);\\n                // document.querySelector('#upload-to-youtube').style.display = 'none';\\n              }\\n            };\\n\\n            var STATUS_POLLING_INTERVAL_MILLIS = 60 * 1000; // One minute.\\n\\n            var UploadVideo = function() {\\n              this.tags = ['recordrtc'];\\n              this.categoryId = 28; // via: http://stackoverflow.com/a/35877512/552182\\n              this.videoId = '';\\n              this.uploadStartTime = 0;\\n            };\\n\\n\\n            UploadVideo.prototype.ready = function(accessToken) {\\n              this.accessToken = accessToken;\\n              this.gapi = gapi;\\n              this.authenticated = true;\\n              false && this.gapi.client.request({\\n                path: '/youtube/v3/channels',\\n                params: {\\n                  part: 'snippet',\\n                  mine: true\\n                },\\n                callback: function(response) {\\n                  if (!response.error) {\\n                    // response.items[0].snippet.title -- channel title\\n                    // response.items[0].snippet.thumbnails.default.url -- channel thumbnail\\n                  }\\n                }.bind(this)\\n              });\\n            };\\n\\n            UploadVideo.prototype.uploadFile = function(fileName, file) {\\n              var metadata = {\\n                snippet: {\\n                  title: fileName,\\n                  description: fileName,\\n                  tags: this.tags,\\n                  categoryId: this.categoryId\\n                },\\n                status: {\\n                  privacyStatus: 'public'\\n                }\\n              };\\n              var uploader = new MediaUploader({\\n                baseUrl: 'https://www.googleapis.com/upload/youtube/v3/videos',\\n                file: file,\\n                token: this.accessToken,\\n                metadata: metadata,\\n                params: {\\n                  part: Object.keys(metadata).join(',')\\n                },\\n                onError: function(data) {\\n                  var message = data;\\n                  try {\\n                    var errorResponse = JSON.parse(data);\\n                    message = errorResponse.error.message;\\n                  } finally {\\n                    alert(message);\\n                  }\\n                }.bind(this),\\n                onProgress: function(data) {\\n                  var bytesUploaded = data.loaded;\\n                  var totalBytes = parseInt(data.total);\\n                  var percentageComplete = parseInt((bytesUploaded * 100) / totalBytes);\\n\\n                  uploadVideo.callback(percentageComplete);\\n                }.bind(this),\\n                onComplete: function(data) {\\n                  var uploadResponse = JSON.parse(data);\\n                  this.videoId = uploadResponse.id;\\n                  this.videoURL = 'https://www.youtube.com/watch?v=' + this.videoId;\\n                  uploadVideo.callback('uploaded', this.videoURL);\\n\\n                  setTimeout(this.pollForVideoStatus, 2000);\\n                }.bind(this)\\n              });\\n              this.uploadStartTime = Date.now();\\n              uploader.upload();\\n            };\\n\\n            UploadVideo.prototype.pollForVideoStatus = function() {\\n              this.gapi.client.request({\\n                path: '/youtube/v3/videos',\\n                params: {\\n                  part: 'status,player',\\n                  id: this.videoId\\n                },\\n                callback: function(response) {\\n                  if (response.error) {\\n                    uploadVideo.pollForVideoStatus();\\n                  } else {\\n                    var uploadStatus = response.items[0].status.uploadStatus;\\n                    switch (uploadStatus) {\\n                      case 'uploaded':\\n                        uploadVideo.callback('uploaded', uploadVideo.videoURL);\\n                        uploadVideo.pollForVideoStatus();\\n                        break;\\n                        case 'processed':\\n                        uploadVideo.callback('processed', uploadVideo.videoURL);\\n                        break;\\n                        default:\\n                        uploadVideo.callback('failed', uploadVideo.videoURL);\\n                        break;\\n                    }\\n                  }\\n                }.bind(this)\\n              });\\n            };\\n\\n        \"), \"\\n\\n        \", HTML.SCRIPT(\"\\n            var DRIVE_UPLOAD_URL = 'https://www.googleapis.com/upload/drive/v2/files/';\\n\\n            var RetryHandler = function() {\\n              this.interval = 1000; // Start at one second\\n              this.maxInterval = 60 * 1000; // Don't wait longer than a minute\\n            };\\n\\n            RetryHandler.prototype.retry = function(fn) {\\n              setTimeout(fn, this.interval);\\n              this.interval = this.nextInterval_();\\n            };\\n\\n            RetryHandler.prototype.reset = function() {\\n              this.interval = 1000;\\n            };\\n\\n            RetryHandler.prototype.nextInterval_ = function() {\\n              var interval = this.interval * 2 + this.getRandomInt_(0, 1000);\\n              return Math.min(interval, this.maxInterval);\\n            };\\n\\n            RetryHandler.prototype.getRandomInt_ = function(min, max) {\\n              return Math.floor(Math.random() * (max - min + 1) + min);\\n            };\\n\\n            var MediaUploader = function(options) {\\n              var noop = function() {};\\n              this.file = options.file;\\n              this.contentType = options.contentType || this.file.type || 'application/octet-stream';\\n              this.metadata = options.metadata || {\\n                'title': this.file.name,\\n                'mimeType': this.contentType\\n              };\\n              this.token = options.token;\\n              this.onComplete = options.onComplete || noop;\\n              this.onProgress = options.onProgress || noop;\\n              this.onError = options.onError || noop;\\n              this.offset = options.offset || 0;\\n              this.chunkSize = options.chunkSize || 0;\\n              this.retryHandler = new RetryHandler();\\n\\n              this.url = options.url;\\n              if (!this.url) {\\n                var params = options.params || {};\\n                params.uploadType = 'resumable';\\n                this.url = this.buildUrl_(options.fileId, params, options.baseUrl);\\n              }\\n              this.httpMethod = options.fileId ? 'PUT' : 'POST';\\n            };\\n\\n            MediaUploader.prototype.upload = function() {\\n              var self = this;\\n              var xhr = new XMLHttpRequest();\\n\\n              xhr.open(this.httpMethod, this.url, true);\\n              xhr.setRequestHeader('Authorization', 'Bearer ' + this.token);\\n              xhr.setRequestHeader('Content-Type', 'application/json');\\n              xhr.setRequestHeader('X-Upload-Content-Length', this.file.size);\\n              xhr.setRequestHeader('X-Upload-Content-Type', this.contentType);\\n\\n              xhr.onload = function(e) {\\n                if (e.target.status < 400) {\\n                  var location = e.target.getResponseHeader('Location');\\n                  this.url = location;\\n                  this.sendFile_();\\n                } else {\\n                  this.onUploadError_(e);\\n                }\\n              }.bind(this);\\n              xhr.onerror = this.onUploadError_.bind(this);\\n              xhr.send(JSON.stringify(this.metadata));\\n            };\\n\\n            MediaUploader.prototype.sendFile_ = function() {\\n              var content = this.file;\\n              var end = this.file.size;\\n\\n              if (this.offset || this.chunkSize) {\\n                // Only bother to slice the file if we're either resuming or uploading in chunks\\n                if (this.chunkSize) {\\n                  end = Math.min(this.offset + this.chunkSize, this.file.size);\\n                }\\n                content = content.slice(this.offset, end);\\n              }\\n\\n              var xhr = new XMLHttpRequest();\\n              xhr.open('PUT', this.url, true);\\n              xhr.setRequestHeader('Content-Type', this.contentType);\\n              xhr.setRequestHeader('Content-Range', 'bytes ' + this.offset + '-' + (end - 1) + '/' + this.file.size);\\n              xhr.setRequestHeader('X-Upload-Content-Type', this.file.type);\\n              if (xhr.upload) {\\n                xhr.upload.addEventListener('progress', this.onProgress);\\n              }\\n              xhr.onload = this.onContentUploadSuccess_.bind(this);\\n              xhr.onerror = this.onContentUploadError_.bind(this);\\n              xhr.send(content);\\n            };\\n\\n            MediaUploader.prototype.resume_ = function() {\\n              var xhr = new XMLHttpRequest();\\n              xhr.open('PUT', this.url, true);\\n              xhr.setRequestHeader('Content-Range', 'bytes */' + this.file.size);\\n              xhr.setRequestHeader('X-Upload-Content-Type', this.file.type);\\n              if (xhr.upload) {\\n                xhr.upload.addEventListener('progress', this.onProgress);\\n              }\\n              xhr.onload = this.onContentUploadSuccess_.bind(this);\\n              xhr.onerror = this.onContentUploadError_.bind(this);\\n              xhr.send();\\n            };\\n\\n            MediaUploader.prototype.extractRange_ = function(xhr) {\\n              var range = xhr.getResponseHeader('Range');\\n              if (range) {\\n                this.offset = parseInt(range.match(/\\\\d+/g).pop(), 10) + 1;\\n              }\\n            };\\n\\n            MediaUploader.prototype.onContentUploadSuccess_ = function(e) {\\n              if (e.target.status == 200 || e.target.status == 201) {\\n                this.onComplete(e.target.response);\\n              } else if (e.target.status == 308) {\\n                this.extractRange_(e.target);\\n                this.retryHandler.reset();\\n                this.sendFile_();\\n              }\\n            };\\n\\n            MediaUploader.prototype.onContentUploadError_ = function(e) {\\n              if (e.target.status && e.target.status < 500) {\\n                this.onError(e.target.response);\\n              } else {\\n                this.retryHandler.retry(this.resume_.bind(this));\\n              }\\n            };\\n\\n            MediaUploader.prototype.onUploadError_ = function(e) {\\n              this.onError(e.target.response); // TODO - Retries for initial upload\\n            };\\n\\n            MediaUploader.prototype.buildQuery_ = function(params) {\\n              params = params || {};\\n              return Object.keys(params).map(function(key) {\\n                return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\\n              }).join('&');\\n            };\\n\\n            MediaUploader.prototype.buildUrl_ = function(id, params, baseUrl) {\\n              var url = baseUrl || DRIVE_UPLOAD_URL;\\n              if (id) {\\n                url += id;\\n              }\\n              var query = this.buildQuery_(params);\\n              if (query) {\\n                url += '?' + query;\\n              }\\n              return url;\\n            };\\n        \"), \"\\n\\n        \", HTML.SCRIPT(\"\\n            var chkFixSeeking = document.querySelector('#chk-fixSeeking');\\n            chkFixSeeking.onchange = function() {\\n                if(this.checked === true) {\\n                    localStorage.setItem(this.id, 'true');\\n                }\\n                else {\\n                    localStorage.removeItem(this.id);\\n                }\\n            };\\n            if(localStorage.getItem(chkFixSeeking.id) === 'true') {\\n                chkFixSeeking.checked = true;\\n            }\\n        \"), \"\\n\\n        \", HTML.SCRIPT(\"\\n            var chkTimeSlice = document.querySelector('#chk-timeSlice');\\n            var timeSlice = false;\\n\\n            if(typeof MediaRecorder === 'undefined') {\\n                chkTimeSlice.disabled = true;\\n            }\\n\\n            chkTimeSlice.addEventListener('change', function() {\\n                if(chkTimeSlice.checked === true) {\\n                    var _timeSlice = prompt('Please enter timeSlice in milliseconds e.g. 1000 or 2000 or 3000.', 1000);\\n                    _timeSlice = parseInt(_timeSlice);\\n                    if(!_timeSlice || _timeSlice == NaN || typeof _timeSlice === 'undefined') {\\n                        timeSlice = false;\\n                        return;\\n                    }\\n\\n                    timeSlice = _timeSlice;\\n                }\\n                else {\\n                    timeSlice = false;\\n                }\\n            }, false);\\n        \"), \"\\n\\n        \", HTML.SCRIPT(\"\\n            var btnPauseRecording = document.querySelector('#btn-pause-recording');\\n            btnPauseRecording.onclick = function() {\\n                if(!btnStartRecording.recordRTC) {\\n                    btnPauseRecording.style.display = 'none';\\n                    return;\\n                }\\n\\n                btnPauseRecording.disabled = true;\\n                if(btnPauseRecording.innerHTML === 'Pause') {\\n                    btnStartRecording.disabled = true;\\n                    chkFixSeeking.parentNode.style.display = 'none';\\n                    btnStartRecording.style.fontSize = '15px';\\n                    btnStartRecording.recordRTC.pauseRecording();\\n                    recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = 'Recording status: paused';\\n                    recordingPlayer.pause();\\n\\n                    btnPauseRecording.style.fontSize = 'inherit';\\n                    setTimeout(function() {\\n                        btnPauseRecording.innerHTML = 'Resume Recording';\\n                        btnPauseRecording.disabled = false;\\n                    }, 2000);\\n                }\\n\\n                if(btnPauseRecording.innerHTML === 'Resume Recording') {\\n                    btnStartRecording.disabled = false;\\n                    chkFixSeeking.parentNode.style.display = 'none';\\n                    btnStartRecording.style.fontSize = 'inherit';\\n                    btnStartRecording.recordRTC.resumeRecording();\\n                    recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = '<img src=\\\"https://cdn.webrtc-experiment.com/images/progress.gif\\\">';\\n                    recordingPlayer.play();\\n\\n                    btnPauseRecording.style.fontSize = '15px';\\n                    btnPauseRecording.innerHTML = 'Pause';\\n                    setTimeout(function() {\\n                        btnPauseRecording.disabled = false;\\n                    }, 2000);\\n                }\\n            };\\n        \"), \"\\n    \");\n}));\nMeteor.startup(Template.body.renderToDocument);\n","bodyAttrs":{}}